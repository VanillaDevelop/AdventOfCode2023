# Advent Of Code 2023
This year, I decided to participate in AoC2023 in a language I am most definitely not familiar with: C++. When looking through my solutions, please note that my focus was not always on finding the most modern or efficient solution, but also to experiment with different features of the C/C++ languages. I have done a more detailed write-up below of my thought process for each day. **Note that I did not switch to a class-based solution design until day 5, so the code may be very cluttered and contain frequent repetitions until then.**

### Day 1
For the first challenge, I simply used iteration over the std::string to find the first and last digit, and multiplied the first digit for each line by 10. For the second challenge, I iterated over the array 9 times, one for each digit, to find the earliest occurrence of a textual version of a digit. The actual check for numeric digits then only has to run to these indices. This solution is still technically in O(n), but it is definitely not clean. Other naive approaches I have seen included replacing text with its corresponding digits, but this leads to problems such as in the string "oneight", where "eight" will not get detected after "one" has been replaced. If I did this challenge again, I would likely use a similar logic, but instead of repeated `find` calls on substrings to find the last instance, I would simply find the first reversed instance of a digit in the reversed string, which would probably perform better, or use [std::string::rfind](https://en.cppreference.com/w/cpp/string/basic_string/rfind), which seems to do this automatically. I wanted to stick to simpler data structures in these first few challenges, to learn more about how I could implement things in somewhat basic C++.

### Day 2
Again, Regex appears as a very logical solution to this problem, especially since only three fixed colours are used. I decided to solve this problem without regex, and, in this challenge, I focused a lot on breaking down the target string into smaller strings, and operating on those to satisfy the "round-based" concept. Both parts of the challenge can be easily solved when using this approach. If I did this challenge again, the main improvement I would make is readability, by better breaking down the methods for splitting the string. Specifically, both here and in the next few challenges, a common issue is that the delimiters in the input are not appended at the end of each line, meaning the final item of each line has to be specially processed outside the loop, leading to repeated code. From day 5 onwards, I try to avoid this, as it constitutes a code smell.

### Day 3
For day 3, the main challenge was somewhat efficiently dealing with locating the position of numbers on a grid and whether they are adjacent to a symbol. I decided to make two grids, one determining the digit, if any, at any given space, and another to determine whether a given space is adjacent to a symbol. For consecutive digits, I multiply the current number by 10 and then add the next digit to find the value of a given sequence of digits. I also keep track of whether any digit was adjacent to a symbol during number construction to find the sum. I think this approach is somewhat reasonable, and the solution mainly suffers from poor readability due to pointer arithmetics (using a 1d array to represent a 2d array), as I wanted to avoid using more modern data structures for the learning experience. Similar to day 2, some issues arise due to missing delimiters at the end of a line, which both led to bugs during development as well as duplicated code. I had a relatively simple idea for the second part of the challenge by replacing my "truth array" (whether the digit is adjacent to any symbol) with an "id array" (the id of the cog to which any digit is adjacent), which can then be used in a simple loop modification to find cog IDs which are adjacent to two numbers and multiply them.

### Day 4
In this challenge, I used vectors and sets for the first time, and started moving away from old C data structures. I used a set to track the winning numbers and calculate the score, which was rather straightforward. For the second challenge, I used a vector as a dynamic array to keep track of the available amount of each scratch card ID. Note that it is not necessary to recursively calculate the results of each scratchcard, and instead simple logic can be used to apply n (number of scratch cards i) extra instances to the next m (number of winning numbers) scratch cards, calculating the full number in a single pass.

### Day 5
On day 5 I decided to begin refactoring my code by wrapping each day's work in a corresponding class that inherits from the abstract class `AoCSolution`, sticking to inline header files to avoid needless complexity (as there is no deeper inheritance structure, it seems unnecessary to create specific header files for this project). The main advantage is that code can be more easily shared between the two parts of the problem, especially code related to the input, and that there is only one main entry point to the program. 

This was for the better, too, since this problem had noticeably more layers of abstraction. The first part is relatively straightforward, although with C++, size_t needs to be used as a data type instead of int, or the values will overflow. Other than that, it is easy enough to make a direct mapping between values and their eventual destinations. The second part, however, is more complicated, and to avoid long computation times, it is necessary to deal with batches as a whole. One trick that helped me a lot here is to convert the [start, range] pairs into [start, end] (inclusive) pairs for both the mappings and the actual seed ranges. Otherwise, for me, it was easy to make errors regarding the inclusion of values at the border, and it was harder to follow the overall thought process. This is a trick I will hopefully keep in mind for future work. 