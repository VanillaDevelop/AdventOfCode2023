# Advent Of Code 2023
This year, I decided to participate in AoC2023 in a language I am most definitely not familiar with: C++. When looking through my solutions, please note that my focus was not always on finding the most modern or efficient solution, but also to experiment with different features of the C/C++ languages. I have done a more detailed write-up below of my thought process for each day. **Note that I did not switch to a class-based solution design until day 5, so the code may be very cluttered and contain frequent repetitions until then.**

### Day 1
For the first challenge, I simply used iteration over the std::string to find the first and last digit, and multiplied the first digit for each line by 10. For the second challenge, I iterated over the array 9 times, one for each digit, to find the earliest occurrence of a textual version of a digit. The actual check for numeric digits then only has to run to these indices. This solution is still technically in O(n), but it is definitely not clean. Other naive approaches I have seen included replacing text with its corresponding digits, but this leads to problems such as in the string "oneight", where "eight" will not get detected after "one" has been replaced. If I did this challenge again, I would likely use a similar logic, but instead of repeated `find` calls on substrings to find the last instance, I would simply find the first reversed instance of a digit in the reversed string, which would probably perform better, or use [std::string::rfind](https://en.cppreference.com/w/cpp/string/basic_string/rfind), which seems to do this automatically. I wanted to stick to simpler data structures in these first few challenges, to learn more about how I could implement things in somewhat basic C++.

### Day 2
Again, Regex appears as a very logical solution to this problem, especially since only three fixed colours are used. I decided to solve this problem without regex, and, in this challenge, I focused a lot on breaking down the target string into smaller strings, and operating on those to satisfy the "round-based" concept. Both parts of the challenge can be easily solved when using this approach. If I did this challenge again, the main improvement I would make is readability, by better breaking down the methods for splitting the string. Specifically, both here and in the next few challenges, a common issue is that the delimiters in the input are not appended at the end of each line, meaning the final item of each line has to be specially processed outside the loop, leading to repeated code. From day 5 onwards, I try to avoid this, as it constitutes a code smell.

### Day 3
For day 3, the main challenge was somewhat efficiently dealing with locating the position of numbers on a grid and whether they are adjacent to a symbol. I decided to make two grids, one determining the digit, if any, at any given space, and another to determine whether a given space is adjacent to a symbol. For consecutive digits, I multiply the current number by 10 and then add the next digit to find the value of a given sequence of digits. I also keep track of whether any digit was adjacent to a symbol during number construction to find the sum. I think this approach is somewhat reasonable, and the solution mainly suffers from poor readability due to pointer arithmetics (using a 1d array to represent a 2d array), as I wanted to avoid using more modern data structures for the learning experience. Similar to day 2, some issues arise due to missing delimiters at the end of a line, which both led to bugs during development as well as duplicated code. I had a relatively simple idea for the second part of the challenge by replacing my "truth array" (whether the digit is adjacent to any symbol) with an "id array" (the id of the cog to which any digit is adjacent), which can then be used in a simple loop modification to find cog IDs which are adjacent to two numbers and multiply them.

### Day 4
In this challenge, I used vectors and sets for the first time, and started moving away from old C data structures. I used a set to track the winning numbers and calculate the score, which was rather straightforward. For the second challenge, I used a vector as a dynamic array to keep track of the available amount of each scratch card ID. Note that it is not necessary to recursively calculate the results of each scratchcard, and instead simple logic can be used to apply n (number of scratch cards i) extra instances to the next m (number of winning numbers) scratch cards, calculating the full number in a single pass.

### Day 5
On day 5 I decided to begin refactoring my code by wrapping each day's work in a corresponding class that inherits from the abstract class `AoCSolution`, sticking to inline header files to avoid needless complexity (as there is no deeper inheritance structure, it seems unnecessary to create specific header files for this project). The main advantage is that code can be more easily shared between the two parts of the problem, especially code related to the input, and that there is only one main entry point to the program. 

This was for the better, too, since this problem had noticeably more layers of abstraction. The first part is relatively straightforward, although with C++, size_t needs to be used as a data type instead of int, or the values will overflow. Other than that, it is easy enough to make a direct mapping between values and their eventual destinations. The second part, however, is more complicated, and to avoid long computation times, it is necessary to deal with batches as a whole. One trick that helped me a lot here is to convert the [start, range] pairs into [start, end] (inclusive) pairs for both the mappings and the actual seed ranges. Otherwise, for me, it was easy to make errors regarding the inclusion of values at the border, and it was harder to follow the overall thought process. This is a trick I will hopefully keep in mind for future work. 

### Day 6
Interestingly, this challenge could easily be solved using simple maths by directly calculating the minimum and maximum of the given inequality `speed > race_time * charge_speed - charge_speed * charge_speed`, which simplifies to `0 > -speed + race_time * charge_speed - 1 * charge_speed^2` and solving for charge_speed. An alternative approach that doesn't use math (because, well, using math is not much programming...) is to simply iterate over the options from the front and back and find the first and last integer for which the equation holds. Yes, this is more inefficient. I don't really have a good excuse for doing this other than that I didn't wanna look up how to apply the quadratic equation. I was also told here that when using a stringstream with the >> operator function ignores leading whitespaces, which would have been an easier way to parse the input than using regex in this case. But at least regex is already a step easier than the character parsing I did in previous days.

### Day 7 
A pretty reasonable challenge, mostly based on setting up sorting logic for poker hands. To determine the type of hand, I used a hash map which stores the count of each character, which should be fairly performant. For tiebreakers, I simply used a string that holds the order of card values, and check which character of the two hands appears first in it. A likely more performant method I've seen changes the face cards (T,J,Q,K) to higher value ASCII counterparts, which removes the need for an additional string to compare against, since we can just compare ASCII values directly. 

For day 2, I added some additional logic which counts and removes jokers from the hand string, and then uses them as wildcards in the logic to determine how many of each card we have. By first sorting the card_count hash map (meaning it needs to be turned into a vector, so it can be sorted to begin with) by the card count value, this logic works out well, since in this game, it is always beneficial to increase the card count of a card as far as possible (as opposed to, e.g., actual poker, where it might be beneficial to make a straight, or something similar).

Otherwise, the logic is relatively straightforward. I had a single bug where a full hand of jokers (JJJJJ) did not correctly produce five-of-a-kind (since the jokers could not be "converted" into another type of card), but this can simply be fixed with a hardcoded check.  Otherwise, I tried to make some more use of string streams (e.g., streaming the "hand" string into character variables to compare one by one, although it would probably in hindsight have been more performant to just compare the string indices...). I learned that they are quite a bit more powerful than I thought (e.g., they can convert numbers autonomously) if streamed into a number type. I also tried to make more use of const refs to make the programs slightly more performant (I'm not particularly checking for performance, but this just seems like good practice), and I had some issues with circular dependencies that I fixed with forward declarations (since I am working out of single header files...so much for good practice), but other than that, it was pretty chill.

This marks the first out of (hopefully) four weeks of AoC done.

### Day 8
Day 8 was a relatively straightforward implementation with a simple graph node data structure. Each node holds a reference to each of its neighbour nodes, allowing for easy traversal. In part 1, it is not necessary to mark the nodes themselves, instead we can just use the corresponding pointer to keep track of our target node. Here, I mainly learned a bit more about how memory returns work in C++ (e.g., returning a pointer to an object created in a function will lead to an invalid pointer), and somehow solved the problem by wrapping everything in std::shared_ptrs. However, I later learned that this is not actually a safe way to handle memory, and that it needs to be ensured that objects that are wrapped in such pointers are created on by the heap, which allows the pointer structure to safely manage the object. Additionally, when handling graph-like structures, cycles can lead to objects never being deallocated, since they are referenced in a cyclical manner. This means my implementation could (and should) definitely be improved. 

For the second part, simply iterating through the graph does not work anymore, as there are 6 large cycles involved, which have a very large LCM. I implemented a relatively costly LCM evaluation here, based on the assumption that the length of the cycles may not be the same as the initial time it takes to get to the corresponding end-node (which turned out not to be the case). I am certain there are mathematically and computationally more sound implementations than this, even if there is an offset (e.g., [this](https://math.stackexchange.com/questions/2218763/how-to-find-lcm-of-two-numbers-when-one-starts-with-an-offset)), but it got the job done. Checks for t mod m = n (where n is the offset, and m is the cycle length) could also make the checks a bit cleaner, even if it likely wouldn't change much performance-wise.

### Day 9
This was a relatively straightforward challenge. I noticed that we could re-use the same array for each iteration, since we only need to store one number from each pass to compute backwards. Otherwise, there was not really much to say about this.

### Day 10
This challenge was a lot more involved again, although the first part was not much of a problem. I mapped the characters to an enum for easier (more readable) processing, and wrote a function that travels along the direction of the pipe. I then simply iterated along the pipe in both directions until I found a common tile to determine the length.

It turns out this implementation was also very helpful for the second part. Effectively, the goal was to determine which fields are enclosed by the pipe loop. The main problem with doing so was that the grid allowed for adjacent tiles, such as ||, which would still count any tile above as being inside the loop. One relatively elegant solution I found was to artificially increase the grid size so that these adjacent borders don't exist, at which point determining which tiles are outside and which are inside is relatively straightforward. My idea was instead to first find tiles that are clearly on the outside (e.g., touching the wall), and then use that info to find a tile for which I know for sure that an adjacent tile is outside. With that knowledge, we can paint along the edge of the loop to find tiles that are on the outside, but "hidden" on the inside. This method requires a few passes so that all adjacent tiles are properly propagated, but it works fine. 

### Day 11
Unlike on day 10, my solution for part 1 really did not help me with part 2 at all here. I physically built an expanded grid of the "universe", hoping that it would come in handy for part 2. I overcomplicated my logic quite a bit, and still stubbornly refused to use data structures that would probably trivialize a lot of this work, so it took me a while to finish this. 

When I saw part two, I immediately understood how I was supposed to solve part 1 - simply count the number of rows and columns that are empty, and add an additional distance value for them. Once I saw the problem, it was a very easy implementation, but I am slightly annoyed that I spent so much time trying to make the expanded grid work...